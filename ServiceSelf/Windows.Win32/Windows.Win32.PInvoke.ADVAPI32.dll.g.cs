// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

#pragma warning disable CS1591,CS1573,CS0465,CS0649,CS8019,CS1570,CS1584,CS1658,CS0436,CS8981
using global::System;
using global::System.Diagnostics;
using global::System.Diagnostics.CodeAnalysis;
using global::System.Runtime.CompilerServices;
using global::System.Runtime.InteropServices;
using global::System.Runtime.Versioning;
using winmdroot = global::Windows.Win32;
namespace Windows.Win32
{

	/// <content>
	/// Contains extern methods from "ADVAPI32.dll".
	/// </content>
	[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.3.106+a37a0b4b70")]
	internal static partial class PInvoke
	{
		/// <summary>Closes a handle to a service control manager or service object.</summary>
		/// <param name="hSCObject">
		/// <para>A handle to the service control manager object or the service object to close. Handles to service control manager objects are returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-openscmanagera">OpenSCManager</a> function, and handles to service objects are returned by either the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-openservicea">OpenService</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-createservicea">CreateService</a> function.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-closeservicehandle#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following error code can be set by the service control manager. Other error codes can be set by registry functions that are called by the service control manager. </para>
		/// <para>This doc was truncated.</para>
		/// </returns>
		/// <remarks>
		/// <para>The <b>CloseServiceHandle</b> function does not destroy the service control manager object referred to by the handle. A service control manager object cannot be destroyed. A service object can be destroyed by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-deleteservice">DeleteService</a> function.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-closeservicehandle#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ADVAPI32.dll", ExactSpelling = true, SetLastError = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        [SupportedOSPlatform("windows")]
        internal static extern winmdroot.Foundation.BOOL CloseServiceHandle(winmdroot.System.Services.SC_HANDLE hSCObject);

        /// <inheritdoc cref="OpenSCManager(winmdroot.Foundation.PCWSTR, winmdroot.Foundation.PCWSTR, uint)"/>
        [SupportedOSPlatform("windows")]
        internal static unsafe CloseServiceHandleSafeHandle OpenSCManager(string lpMachineName, string lpDatabaseName, uint dwDesiredAccess)
		{
			fixed (char* lpDatabaseNameLocal = lpDatabaseName)
			{
				fixed (char* lpMachineNameLocal = lpMachineName)
				{
					winmdroot.System.Services.SC_HANDLE __result = PInvoke.OpenSCManager(lpMachineNameLocal, lpDatabaseNameLocal, dwDesiredAccess);
					return new CloseServiceHandleSafeHandle(__result, ownsHandle: true);
				}
			}
		}

		/// <summary>Establishes a connection to the service control manager on the specified computer and opens the specified service control manager database. (Unicode)</summary>
		/// <param name="lpMachineName">The name of the target computer. If the pointer is NULL or points to an empty string, the function connects to the service control manager on the local computer.</param>
		/// <param name="lpDatabaseName">The name of the service control manager database. This parameter should be set to SERVICES_ACTIVE_DATABASE. If it is NULL, the SERVICES_ACTIVE_DATABASE database is opened by default.</param>
		/// <param name="dwDesiredAccess">
		/// <para>The access to the service control manager. For a list of access rights, see <a href="https://docs.microsoft.com/windows/desktop/Services/service-security-and-access-rights">Service Security and Access Rights</a>.</para>
		/// <para>Before granting the requested access rights, the system checks the access token of the calling process against the discretionary access-control list of the security descriptor associated with the service control manager. The SC_MANAGER_CONNECT access right is implicitly specified by calling this function.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-openscmanagerw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>If the function succeeds, the return value is a handle to the specified service control manager database. If the function fails, the return value is NULL. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following error codes can be set by the SCM. Other error codes can be set by the registry functions that are called by the SCM. </para>
		/// <para>This doc was truncated.</para>
		/// </returns>
		/// <remarks>
		/// <para>When a process uses the <b>OpenSCManager</b> function to open a handle to a service control manager database, the system performs a security check before granting the requested access. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Services/service-security-and-access-rights">Service Security and Access Rights</a>. If the current user does not have proper access when connecting to a service on another computer, the  <b>OpenSCManager</b> function call fails. To connect to a service remotely, call the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-logonusera">LogonUser</a> function with LOGON32_LOGON_NEW_CREDENTIALS and then call <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-impersonateloggedonuser">ImpersonateLoggedOnUser</a> before calling <b>OpenSCManager</b>. For more information about connecting to services remotely, see <a href="https://docs.microsoft.com/windows/desktop/Services/services-and-rpc-tcp">Services and RPC/TCP</a>. Only processes with Administrator privileges are able to open a database handle that can be used by the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-createservicea">CreateService</a> function. The returned handle is only valid for the process that called the <b>OpenSCManager</b> function. It can be closed by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-closeservicehandle">CloseServiceHandle</a> function.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-openscmanagerw#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ADVAPI32.dll", ExactSpelling = true, EntryPoint = "OpenSCManagerW", SetLastError = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        [SupportedOSPlatform("windows")]
        internal static extern winmdroot.System.Services.SC_HANDLE OpenSCManager(winmdroot.Foundation.PCWSTR lpMachineName, winmdroot.Foundation.PCWSTR lpDatabaseName, uint dwDesiredAccess);

        /// <inheritdoc cref="OpenService(winmdroot.System.Services.SC_HANDLE, winmdroot.Foundation.PCWSTR, uint)"/>
        [SupportedOSPlatform("windows")]
        internal static unsafe CloseServiceHandleSafeHandle OpenService(SafeHandle hSCManager, string lpServiceName, uint dwDesiredAccess)
		{
			bool hSCManagerAddRef = false;
			try
			{
				fixed (char* lpServiceNameLocal = lpServiceName)
				{
					winmdroot.System.Services.SC_HANDLE hSCManagerLocal;
					if (hSCManager is object)
					{
						hSCManager.DangerousAddRef(ref hSCManagerAddRef);
						hSCManagerLocal = (winmdroot.System.Services.SC_HANDLE)hSCManager.DangerousGetHandle();
					}
					else
						throw new ArgumentNullException(nameof(hSCManager));
					winmdroot.System.Services.SC_HANDLE __result = PInvoke.OpenService(hSCManagerLocal, lpServiceNameLocal, dwDesiredAccess);
					return new CloseServiceHandleSafeHandle(__result, ownsHandle: true);
				}
			}
			finally
			{
				if (hSCManagerAddRef)
					hSCManager.DangerousRelease();
			}
		}

		/// <summary>Opens an existing service. (Unicode)</summary>
		/// <param name="hSCManager">
		/// <para>A handle to the service control manager database. The <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-openscmanagera">OpenSCManager</a> function returns this handle. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Services/service-security-and-access-rights">Service Security and Access Rights</a>.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-openservicew#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="lpServiceName">
		/// <para>The name of the service to be opened. This is the name specified by the <i>lpServiceName</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-createservicea">CreateService</a> function when the service object was created, not the service display name that is shown by user interface applications to identify the service. The maximum string length is 256 characters. The service control manager database preserves the case of the characters, but service name comparisons are always case insensitive. Forward-slash (/) and backslash (\\) are invalid service name characters.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-openservicew#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="dwDesiredAccess">
		/// <para>The access to the service. For a list of access rights, see <a href="https://docs.microsoft.com/windows/desktop/Services/service-security-and-access-rights">Service Security and Access Rights</a>.</para>
		/// <para>Before granting the requested access, the system checks the access token of the calling process against the discretionary access-control list of the security descriptor associated with the service object.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-openservicew#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>If the function succeeds, the return value is a handle to the service. If the function fails, the return value is NULL. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following error codes can be set by the service control manager. Others can be set by the registry functions that are called by the service control manager. </para>
		/// <para>This doc was truncated.</para>
		/// </returns>
		/// <remarks>
		/// <para>The returned handle is only valid for the process that called <b>OpenService</b>. It can be closed by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-closeservicehandle">CloseServiceHandle</a> function. To use <b>OpenService</b>, no privileges are required aside from <b>SC_MANAGER_CONNECT</b>.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-openservicew#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ADVAPI32.dll", ExactSpelling = true, EntryPoint = "OpenServiceW", SetLastError = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        [SupportedOSPlatform("windows")]
        internal static extern winmdroot.System.Services.SC_HANDLE OpenService(winmdroot.System.Services.SC_HANDLE hSCManager, winmdroot.Foundation.PCWSTR lpServiceName, uint dwDesiredAccess);

        /// <inheritdoc cref="CreateService(winmdroot.System.Services.SC_HANDLE, winmdroot.Foundation.PCWSTR, winmdroot.Foundation.PCWSTR, uint, winmdroot.System.Services.ENUM_SERVICE_TYPE, winmdroot.System.Services.SERVICE_START_TYPE, winmdroot.System.Services.SERVICE_ERROR, winmdroot.Foundation.PCWSTR, winmdroot.Foundation.PCWSTR, uint*, winmdroot.Foundation.PCWSTR, winmdroot.Foundation.PCWSTR, winmdroot.Foundation.PCWSTR)"/>
        [SupportedOSPlatform("windows")]
        internal static unsafe CloseServiceHandleSafeHandle CreateService(SafeHandle hSCManager, string lpServiceName, string lpDisplayName, uint dwDesiredAccess, winmdroot.System.Services.ENUM_SERVICE_TYPE dwServiceType, winmdroot.System.Services.SERVICE_START_TYPE dwStartType, winmdroot.System.Services.SERVICE_ERROR dwErrorControl, string lpBinaryPathName, string lpLoadOrderGroup, uint* lpdwTagId, string lpDependencies, string lpServiceStartName, string lpPassword)
		{
			bool hSCManagerAddRef = false;
			try
			{
				fixed (char* lpPasswordLocal = lpPassword)
				{
					fixed (char* lpServiceStartNameLocal = lpServiceStartName)
					{
						fixed (char* lpDependenciesLocal = lpDependencies)
						{
							fixed (char* lpLoadOrderGroupLocal = lpLoadOrderGroup)
							{
								fixed (char* lpBinaryPathNameLocal = lpBinaryPathName)
								{
									fixed (char* lpDisplayNameLocal = lpDisplayName)
									{
										fixed (char* lpServiceNameLocal = lpServiceName)
										{
											winmdroot.System.Services.SC_HANDLE hSCManagerLocal;
											if (hSCManager is object)
											{
												hSCManager.DangerousAddRef(ref hSCManagerAddRef);
												hSCManagerLocal = (winmdroot.System.Services.SC_HANDLE)hSCManager.DangerousGetHandle();
											}
											else
												throw new ArgumentNullException(nameof(hSCManager));
											winmdroot.System.Services.SC_HANDLE __result = PInvoke.CreateService(hSCManagerLocal, lpServiceNameLocal, lpDisplayNameLocal, dwDesiredAccess, dwServiceType, dwStartType, dwErrorControl, lpBinaryPathNameLocal, lpLoadOrderGroupLocal, lpdwTagId, lpDependenciesLocal, lpServiceStartNameLocal, lpPasswordLocal);
											return new CloseServiceHandleSafeHandle(__result, ownsHandle: true);
										}
									}
								}
							}
						}
					}
				}
			}
			finally
			{
				if (hSCManagerAddRef)
					hSCManager.DangerousRelease();
			}
		}

		/// <summary>Creates a service object and adds it to the specified service control manager database. (Unicode)</summary>
		/// <param name="hSCManager">
		/// <para>A handle to the service control manager database. This handle is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-openscmanagera">OpenSCManager</a> function and must have the <b>SC_MANAGER_CREATE_SERVICE</b> access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Services/service-security-and-access-rights">Service Security and Access Rights</a>.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-createservicew#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="lpServiceName">The name of the service to install. The maximum string length is 256 characters. The service control manager database preserves the case of the characters, but service name comparisons are always case insensitive. Forward-slash (/) and backslash (\\) are not valid service name characters.</param>
		/// <param name="lpDisplayName">The display name to be used by user interface programs to identify the service. This string has a maximum length of 256 characters. The name is case-preserved in the service control manager. Display name comparisons are always case-insensitive.</param>
		/// <param name="dwDesiredAccess">
		/// <para>The access to the service. Before granting the requested access, the system checks the access token of the calling process. For a list of values, see <a href="https://docs.microsoft.com/windows/desktop/Services/service-security-and-access-rights">Service Security and Access Rights</a>.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-createservicew#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="dwServiceType"></param>
		/// <param name="dwStartType"></param>
		/// <param name="dwErrorControl"></param>
		/// <param name="lpBinaryPathName">
		/// <para>The fully qualified path to the service binary file. If the path contains a space, it must be quoted so that it is correctly interpreted. For example, "d:\\my share\\myservice.exe" should be specified as "\"d:\\my share\\myservice.exe\"".</para>
		/// <para>The path can also include arguments for an auto-start service. For example, "d:\\myshare\\myservice.exe arg1 arg2". These arguments are passed to the service entry point (typically the <b>main</b> function). If you specify a path on another computer, the share must be accessible by the computer account of the local computer because this is the security context used in the remote call. However, this requirement allows any potential vulnerabilities in the remote computer to affect the local computer. Therefore, it is best to use a local file.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-createservicew#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="lpLoadOrderGroup">
		/// <para>The names of the load ordering group of which this service is a member. Specify NULL or an empty string if the service does not belong to a group.</para>
		/// <para>The startup program uses load ordering groups to load groups of services in a specified order with respect to the other groups. The list of load ordering groups is contained in the following registry value: <b>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\ServiceGroupOrder</b></para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-createservicew#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="lpdwTagId">
		/// <para>A pointer to a variable that receives a tag value that is unique in the group specified in the <i>lpLoadOrderGroup</i> parameter. Specify NULL if you are not changing the existing tag.</para>
		/// <para>You can use a tag for ordering service startup within a load ordering group by specifying a tag order vector in the following registry value:<b>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\GroupOrderList</b></para>
		/// <para>Tags are only evaluated for driver services that have <b>SERVICE_BOOT_START</b> or <b>SERVICE_SYSTEM_START</b> start types.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-createservicew#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="lpDependencies">
		/// <para>A pointer to a double null-terminated array of null-separated names of services or load ordering groups that the system must start before this service. Specify NULL or an empty string if the service has no dependencies. Dependency on a group means that this service can run if at least one member of the group is running after an attempt to start all members of the group.</para>
		/// <para>You must prefix group names with <b>SC_GROUP_IDENTIFIER</b> so that they can be distinguished from a service name, because services and service groups share the same name space.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-createservicew#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="lpServiceStartName">
		/// <para>The name of the account under which the service should run. If the service type is SERVICE_WIN32_OWN_PROCESS, use an account name in the form <i>DomainName</i>&#92;<i>UserName</i>. The service process will be logged on as this user. If the account belongs to the built-in domain, you can specify .&#92;<i>UserName</i>.</para>
		/// <para>If this parameter is NULL, <b>CreateService</b> uses the <a href="https://docs.microsoft.com/windows/desktop/Services/localsystem-account">LocalSystem account</a>. If the service type specifies <b>SERVICE_INTERACTIVE_PROCESS</b>, the service must run in the LocalSystem account. If this parameter is NT AUTHORITY\LocalService, <b>CreateService</b> uses the <a href="https://docs.microsoft.com/windows/desktop/Services/localservice-account">LocalService account</a>. If the parameter is NT AUTHORITY\NetworkService, <b>CreateService</b> uses the <a href="https://docs.microsoft.com/windows/desktop/Services/networkservice-account">NetworkService account</a>. A shared process can run as any user. If the service type is <b>SERVICE_KERNEL_DRIVER</b> or <b>SERVICE_FILE_SYSTEM_DRIVER</b>, the name is the driver object name that the system uses to load the device driver. Specify NULL if the driver is to use a default object name created by the I/O system. A service can be configured to use a managed account or a virtual  account. If the service is configured to use a managed service account, the name is the managed service account name. If the service is configured to use a virtual  account, specify the name as NT SERVICE&#92;<i>ServiceName</i>. For more information about managed service accounts and virtual accounts, see the <a href="https://docs.microsoft.com/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/dd548356(v=ws.10)">Service Accounts Step-by-Step Guide</a>. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Managed service accounts and virtual accounts are not supported until Windows 7 and Windows Server 2008 R2.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-createservicew#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="lpPassword">
		/// <para>The password to the account name specified by the <i>lpServiceStartName</i> parameter. Specify an empty string if the account has no password or if the service runs in the LocalService, NetworkService, or LocalSystem account. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Services/service-record-list">Service Record List</a>.</para>
		/// <para>If the account name specified by the  <i>lpServiceStartName</i> parameter is the name of  a managed service account or virtual account name, the <i>lpPassword</i> parameter must be NULL. Passwords are ignored for driver services.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-createservicew#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>If the function succeeds, the return value is a handle to the service. If the function fails, the return value is NULL. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following error codes can be set by the service control manager. Other error codes can be set by the registry functions that are called by the service control manager. </para>
		/// <para>This doc was truncated.</para>
		/// </returns>
		/// <remarks>
		/// <para>The <b>CreateService</b> function creates a service object and installs it in the service control manager database by creating a key with the same name as the service under the following registry key:<b>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services</b></para>
		/// <para>Information specified by <b>CreateService</b>, <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-changeserviceconfiga">ChangeServiceConfig</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-changeserviceconfig2a">ChangeServiceConfig2</a> is saved as values under this key. The following are examples of values stored for a service. </para>
		/// <para>This doc was truncated.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-createservicew#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ADVAPI32.dll", ExactSpelling = true, EntryPoint = "CreateServiceW", SetLastError = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        [SupportedOSPlatform("windows")]
        internal static extern unsafe winmdroot.System.Services.SC_HANDLE CreateService(winmdroot.System.Services.SC_HANDLE hSCManager, winmdroot.Foundation.PCWSTR lpServiceName, winmdroot.Foundation.PCWSTR lpDisplayName, uint dwDesiredAccess, winmdroot.System.Services.ENUM_SERVICE_TYPE dwServiceType, winmdroot.System.Services.SERVICE_START_TYPE dwStartType, winmdroot.System.Services.SERVICE_ERROR dwErrorControl, winmdroot.Foundation.PCWSTR lpBinaryPathName, winmdroot.Foundation.PCWSTR lpLoadOrderGroup, [Optional] uint* lpdwTagId, winmdroot.Foundation.PCWSTR lpDependencies, winmdroot.Foundation.PCWSTR lpServiceStartName, winmdroot.Foundation.PCWSTR lpPassword);

        /// <inheritdoc cref="StartService(winmdroot.System.Services.SC_HANDLE, uint, winmdroot.Foundation.PCWSTR*)"/>
        [SupportedOSPlatform("windows")]
        internal static unsafe winmdroot.Foundation.BOOL StartService(SafeHandle hService, ReadOnlySpan<winmdroot.Foundation.PCWSTR> lpServiceArgVectors)
		{
			bool hServiceAddRef = false;
			try
			{
				fixed (winmdroot.Foundation.PCWSTR* lpServiceArgVectorsLocal = lpServiceArgVectors)
				{
					winmdroot.System.Services.SC_HANDLE hServiceLocal;
					if (hService is object)
					{
						hService.DangerousAddRef(ref hServiceAddRef);
						hServiceLocal = (winmdroot.System.Services.SC_HANDLE)hService.DangerousGetHandle();
					}
					else
						throw new ArgumentNullException(nameof(hService));
					winmdroot.Foundation.BOOL __result = PInvoke.StartService(hServiceLocal, (uint )lpServiceArgVectors.Length, lpServiceArgVectorsLocal);
					return __result;
				}
			}
			finally
			{
				if (hServiceAddRef)
					hService.DangerousRelease();
			}
		}

		/// <summary>Starts a service. (Unicode)</summary>
		/// <param name="hService">
		/// <para>A handle to the service. This handle is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-openservicea">OpenService</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-createservicea">CreateService</a> function, and it must have the SERVICE_START access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Services/service-security-and-access-rights">Service Security and Access Rights</a>.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-startservicew#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="dwNumServiceArgs">The number of strings in the <i>lpServiceArgVectors</i> array. If <i>lpServiceArgVectors</i> is NULL, this parameter can be zero.</param>
		/// <param name="lpServiceArgVectors">
		/// <para>The null-terminated strings to be passed to the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nc-winsvc-lpservice_main_functiona">ServiceMain</a> function for the service as arguments. If there are no arguments, this parameter can be NULL. Otherwise, the first argument (lpServiceArgVectors[0]) is the name of the service, followed by any additional arguments (lpServiceArgVectors[1] through lpServiceArgVectors[dwNumServiceArgs-1]). Driver services do not receive these arguments.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-startservicew#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following error codes can be set by the service control manager. Others can be set by the registry functions that are called by the service control manager. </para>
		/// <para>This doc was truncated.</para>
		/// </returns>
		/// <remarks>
		/// <para>When a driver service is started, the <b>StartService</b> function does not return until the device driver has finished initializing. When a service is started, the Service Control Manager (SCM) spawns the service process, if necessary. If the specified service shares a process with other services, the required process may already exist. The <b>StartService</b> function does not wait for the first status update from the new service, because it can take a while. Instead, it returns when the SCM receives notification from the service control dispatcher that the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nc-winsvc-lpservice_main_functiona">ServiceMain</a> thread for this service was created successfully. The SCM sets the following default status values before returning from <b>StartService</b>: </para>
		/// <para>This doc was truncated.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-startservicew#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ADVAPI32.dll", ExactSpelling = true, EntryPoint = "StartServiceW", SetLastError = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        [SupportedOSPlatform("windows")]
        internal static extern unsafe winmdroot.Foundation.BOOL StartService(winmdroot.System.Services.SC_HANDLE hService, uint dwNumServiceArgs, [Optional] winmdroot.Foundation.PCWSTR* lpServiceArgVectors);

        /// <inheritdoc cref="DeleteService(winmdroot.System.Services.SC_HANDLE)"/>
        [SupportedOSPlatform("windows")]
        internal static unsafe winmdroot.Foundation.BOOL DeleteService(SafeHandle hService)
		{
			bool hServiceAddRef = false;
			try
			{
				winmdroot.System.Services.SC_HANDLE hServiceLocal;
				if (hService is object)
				{
					hService.DangerousAddRef(ref hServiceAddRef);
					hServiceLocal = (winmdroot.System.Services.SC_HANDLE)hService.DangerousGetHandle();
				}
				else
					throw new ArgumentNullException(nameof(hService));
				winmdroot.Foundation.BOOL __result = PInvoke.DeleteService(hServiceLocal);
				return __result;
			}
			finally
			{
				if (hServiceAddRef)
					hService.DangerousRelease();
			}
		}

		/// <summary>Marks the specified service for deletion from the service control manager database.</summary>
		/// <param name="hService">
		/// <para>A handle to the service. This handle is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-openservicea">OpenService</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-createservicea">CreateService</a> function, and it must have the DELETE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Services/service-security-and-access-rights">Service Security and Access Rights</a>.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-deleteservice#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following error codes may be set by the service control manager. Others may be set by the registry functions that are called by the service control manager. </para>
		/// <para>This doc was truncated.</para>
		/// </returns>
		/// <remarks>
		/// <para>The <b>DeleteService</b> function marks a service for deletion from the service control manager database. The database entry is not removed until all open handles to the service have been closed by calls to the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-closeservicehandle">CloseServiceHandle</a> function, and the service is not running. A running service is stopped by a call to the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-controlservice">ControlService</a> function with the SERVICE_CONTROL_STOP control code. If the service cannot be stopped, the database entry is removed when the system is restarted. The service control manager deletes the service by deleting the service key and its subkeys from the registry.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-deleteservice#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ADVAPI32.dll", ExactSpelling = true, SetLastError = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        [SupportedOSPlatform("windows")]
        internal static extern winmdroot.Foundation.BOOL DeleteService(winmdroot.System.Services.SC_HANDLE hService);

        /// <inheritdoc cref="QueryServiceStatus(winmdroot.System.Services.SC_HANDLE, winmdroot.System.Services.SERVICE_STATUS*)"/>
        [SupportedOSPlatform("windows")]
        internal static unsafe winmdroot.Foundation.BOOL QueryServiceStatus(SafeHandle hService, out winmdroot.System.Services.SERVICE_STATUS lpServiceStatus)
		{
			bool hServiceAddRef = false;
			try
			{
				fixed (winmdroot.System.Services.SERVICE_STATUS* lpServiceStatusLocal = &lpServiceStatus)
				{
					winmdroot.System.Services.SC_HANDLE hServiceLocal;
					if (hService is object)
					{
						hService.DangerousAddRef(ref hServiceAddRef);
						hServiceLocal = (winmdroot.System.Services.SC_HANDLE)hService.DangerousGetHandle();
					}
					else
						throw new ArgumentNullException(nameof(hService));
					winmdroot.Foundation.BOOL __result = PInvoke.QueryServiceStatus(hServiceLocal, lpServiceStatusLocal);
					return __result;
				}
			}
			finally
			{
				if (hServiceAddRef)
					hService.DangerousRelease();
			}
		}

		/// <summary>Retrieves the current status of the specified service.</summary>
		/// <param name="hService">
		/// <para>A handle to the service. This handle is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-openservicea">OpenService</a> or the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-createservicea">CreateService</a> function, and it must have the SERVICE_QUERY_STATUS access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Services/service-security-and-access-rights">Service Security and Access Rights</a>.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-queryservicestatus#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="lpServiceStatus">
		/// <para>A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/ns-winsvc-service_status">SERVICE_STATUS</a> structure that receives the status information.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-queryservicestatus#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following error codes can be set by the service control manager. Other error codes can be set by the registry functions that are called by the service control manager. </para>
		/// <para>This doc was truncated.</para>
		/// </returns>
		/// <remarks>
		/// <para>The <b>QueryServiceStatus</b> function returns the most recent service status information reported to the service control manager. If the service just changed its status, it may not have updated the service control manager yet.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-queryservicestatus#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ADVAPI32.dll", ExactSpelling = true, SetLastError = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        [SupportedOSPlatform("windows")]
        internal static extern unsafe winmdroot.Foundation.BOOL QueryServiceStatus(winmdroot.System.Services.SC_HANDLE hService, winmdroot.System.Services.SERVICE_STATUS* lpServiceStatus);

        /// <inheritdoc cref="QueryServiceStatusEx(winmdroot.System.Services.SC_HANDLE, winmdroot.System.Services.SC_STATUS_TYPE, byte*, uint, uint*)"/>
        [SupportedOSPlatform("windows")]
        internal static unsafe winmdroot.Foundation.BOOL QueryServiceStatusEx(SafeHandle hService, winmdroot.System.Services.SC_STATUS_TYPE InfoLevel, Span<byte> lpBuffer, out uint pcbBytesNeeded)
		{
			bool hServiceAddRef = false;
			try
			{
				fixed (uint* pcbBytesNeededLocal = &pcbBytesNeeded)
				{
					fixed (byte* lpBufferLocal = lpBuffer)
					{
						winmdroot.System.Services.SC_HANDLE hServiceLocal;
						if (hService is object)
						{
							hService.DangerousAddRef(ref hServiceAddRef);
							hServiceLocal = (winmdroot.System.Services.SC_HANDLE)hService.DangerousGetHandle();
						}
						else
							throw new ArgumentNullException(nameof(hService));
						winmdroot.Foundation.BOOL __result = PInvoke.QueryServiceStatusEx(hServiceLocal, InfoLevel, lpBufferLocal, (uint )lpBuffer.Length, pcbBytesNeededLocal);
						return __result;
					}
				}
			}
			finally
			{
				if (hServiceAddRef)
					hService.DangerousRelease();
			}
		}

		/// <summary>Retrieves the current status of the specified service based on the specified information level.</summary>
		/// <param name="hService">
		/// <para>A handle to the service. This handle is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-createservicea">CreateService</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-openservicea">OpenService</a> function, and it must have the SERVICE_QUERY_STATUS access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Services/service-security-and-access-rights">Service Security and Access Rights</a>.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-queryservicestatusex#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="InfoLevel">
		/// <para>The service attributes to be returned. Use SC_STATUS_PROCESS_INFO to retrieve the service status information. The <i>lpBuffer</i> parameter is a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/ns-winsvc-service_status_process">SERVICE_STATUS_PROCESS</a> structure.</para>
		/// <para>Currently, no other information levels are defined.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-queryservicestatusex#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="lpBuffer">
		/// <para>A pointer to the buffer that receives the status information. The format of this data depends on the value of the <i>InfoLevel</i> parameter. The maximum size of this array is 8K bytes. To determine the required size, specify NULL for this parameter and 0 for the <i>cbBufSize</i> parameter. The function will fail and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return ERROR_INSUFFICIENT_BUFFER. The <i>pcbBytesNeeded</i> parameter will receive the required size.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-queryservicestatusex#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="cbBufSize">The size of the buffer pointed to by the <i>lpBuffer</i> parameter, in bytes.</param>
		/// <param name="pcbBytesNeeded">A pointer to a variable that receives the number of bytes needed to store all status information, if the function fails with ERROR_INSUFFICIENT_BUFFER.</param>
		/// <returns>
		/// <para>If the function succeeds, the return value is nonzero.</para>
		/// <para>If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following errors can be returned. </para>
		/// <para>This doc was truncated.</para>
		/// </returns>
		/// <remarks>
		/// <para>The <b>QueryServiceStatusEx</b> function returns the most recent service status information reported to the service control manager. If the service just changed its status, it may not have updated the service control manager yet. The process identifier returned in the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/ns-winsvc-service_status_process">SERVICE_STATUS_PROCESS</a> structure is valid provided that the state of the service is one of SERVICE_RUNNING, SERVICE_PAUSE_PENDING, SERVICE_PAUSED, or SERVICE_CONTINUE_PENDING. If the service is in a SERVICE_START_PENDING or SERVICE_STOP_PENDING state, however, the process identifier may not be valid, and if the service is in the SERVICE_STOPPED state, it is never valid.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-queryservicestatusex#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ADVAPI32.dll", ExactSpelling = true, SetLastError = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        [SupportedOSPlatform("windows")]
        internal static extern unsafe winmdroot.Foundation.BOOL QueryServiceStatusEx(winmdroot.System.Services.SC_HANDLE hService, winmdroot.System.Services.SC_STATUS_TYPE InfoLevel, [Optional] byte* lpBuffer, uint cbBufSize, uint* pcbBytesNeeded);

        /// <inheritdoc cref="QueryServiceConfig(winmdroot.System.Services.SC_HANDLE, winmdroot.System.Services.QUERY_SERVICE_CONFIGW*, uint, uint*)"/>
        [SupportedOSPlatform("windows")]
        internal static unsafe winmdroot.Foundation.BOOL QueryServiceConfig(SafeHandle hService, winmdroot.System.Services.QUERY_SERVICE_CONFIGW* lpServiceConfig, uint cbBufSize, out uint pcbBytesNeeded)
		{
			bool hServiceAddRef = false;
			try
			{
				fixed (uint* pcbBytesNeededLocal = &pcbBytesNeeded)
				{
					winmdroot.System.Services.SC_HANDLE hServiceLocal;
					if (hService is object)
					{
						hService.DangerousAddRef(ref hServiceAddRef);
						hServiceLocal = (winmdroot.System.Services.SC_HANDLE)hService.DangerousGetHandle();
					}
					else
						throw new ArgumentNullException(nameof(hService));
					winmdroot.Foundation.BOOL __result = PInvoke.QueryServiceConfig(hServiceLocal, lpServiceConfig, cbBufSize, pcbBytesNeededLocal);
					return __result;
				}
			}
			finally
			{
				if (hServiceAddRef)
					hService.DangerousRelease();
			}
		}

		/// <summary>Retrieves the configuration parameters of the specified service. (Unicode)</summary>
		/// <param name="hService">
		/// <para>A handle to the service. This handle is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-openservicea">OpenService</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-createservicea">CreateService</a> function, and it must have the SERVICE_QUERY_CONFIG access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Services/service-security-and-access-rights">Service Security and Access Rights</a>.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-queryserviceconfigw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="lpServiceConfig">
		/// <para>A pointer to a buffer that receives the service configuration information. The format of the data is a <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/ns-winsvc-query_service_configa">QUERY_SERVICE_CONFIG</a> structure. The maximum size of this array is 8K bytes. To determine the required size, specify NULL for this parameter and 0 for the <i>cbBufSize</i> parameter. The function will fail and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return ERROR_INSUFFICIENT_BUFFER. The <i>pcbBytesNeeded</i> parameter will receive the required size.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-queryserviceconfigw#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="cbBufSize">The size of the buffer pointed to by the <i>lpServiceConfig</i> parameter, in bytes.</param>
		/// <param name="pcbBytesNeeded">A pointer to a variable that receives the number of bytes needed to store all the configuration information, if the function fails with ERROR_INSUFFICIENT_BUFFER.</param>
		/// <returns>
		/// <para>If the function succeeds, the return value is nonzero.</para>
		/// <para>If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following error codes can be set by the service control manager. Others can be set by the registry functions that are called by the service control manager. </para>
		/// <para>This doc was truncated.</para>
		/// </returns>
		/// <remarks>
		/// <para>The <b>QueryServiceConfig</b> function returns the service configuration information kept in the registry for a particular service. This configuration information is first set by a service control program using the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-createservicea">CreateService</a> function. This information may have been updated by a service configuration program using the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-changeserviceconfiga">ChangeServiceConfig</a> function. If the service was running when the configuration information was last changed, the information returned by <b>QueryServiceConfig</b> will not reflect the current configuration of the service. Instead, it will reflect the configuration of the service when it is next run. The <b>DisplayName</b> key is an exception to this. When the <b>DisplayName</b> key is changed, it takes effect immediately, regardless of whether the service is running.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-queryserviceconfigw#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ADVAPI32.dll", ExactSpelling = true, EntryPoint = "QueryServiceConfigW", SetLastError = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        [SupportedOSPlatform("windows")]
        internal static extern unsafe winmdroot.Foundation.BOOL QueryServiceConfig(winmdroot.System.Services.SC_HANDLE hService, [Optional] winmdroot.System.Services.QUERY_SERVICE_CONFIGW* lpServiceConfig, uint cbBufSize, uint* pcbBytesNeeded);

        /// <inheritdoc cref="ChangeServiceConfig2W(winmdroot.System.Services.SC_HANDLE, winmdroot.System.Services.SERVICE_CONFIG, void*)"/>
        [SupportedOSPlatform("windows")]
        internal static unsafe winmdroot.Foundation.BOOL ChangeServiceConfig2W(SafeHandle hService, winmdroot.System.Services.SERVICE_CONFIG dwInfoLevel, void* lpInfo)
		{
			bool hServiceAddRef = false;
			try
			{
				winmdroot.System.Services.SC_HANDLE hServiceLocal;
				if (hService is object)
				{
					hService.DangerousAddRef(ref hServiceAddRef);
					hServiceLocal = (winmdroot.System.Services.SC_HANDLE)hService.DangerousGetHandle();
				}
				else
					throw new ArgumentNullException(nameof(hService));
				winmdroot.Foundation.BOOL __result = PInvoke.ChangeServiceConfig2W(hServiceLocal, dwInfoLevel, lpInfo);
				return __result;
			}
			finally
			{
				if (hServiceAddRef)
					hService.DangerousRelease();
			}
		}

		/// <summary>Changes the optional configuration parameters of a service. (Unicode)</summary>
		/// <param name="hService">
		/// <para>A handle to the service. This handle is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-openservicea">OpenService</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-createservicea">CreateService</a> function and must have the <b>SERVICE_CHANGE_CONFIG</b> access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Services/service-security-and-access-rights">Service Security and Access Rights</a>.</para>
		/// <para>If the service controller handles the <b>SC_ACTION_RESTART</b> action, <i>hService</i> must have the <b>SERVICE_START</b> access right.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-changeserviceconfig2w#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="dwInfoLevel"></param>
		/// <param name="lpInfo">A pointer to the new value to be set for the configuration information. The format of this data depends on the value of the <i>dwInfoLevel</i> parameter. If this value is <b>NULL</b>, the information remains unchanged.</param>
		/// <returns>
		/// <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
		/// </returns>
		/// <remarks>
		/// <para>The <b>ChangeServiceConfig2</b> function changes the optional configuration information for the specified service in the service control manager database. You can obtain the current optional configuration information by using the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-queryserviceconfig2a">QueryServiceConfig2</a> function. You cannot set the <b>SERVICE_CONFIG_FAILURE_ACTIONS</b> value for a service that shares the service control manager's process. This includes all services whose executable image is "Services.exe". You can change and query additional configuration information using the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-changeserviceconfiga">ChangeServiceConfig</a> and <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-queryserviceconfiga">QueryServiceConfig</a> functions, respectively. If a service is configured to restart after it finishes with an error, the service control manager queues the restart action to occur after the specified time delay. A queued restart action cannot be canceled. If the service is manually restarted and then stopped before the queued restart action occurs, the service will restart unexpectedly when the time delay elapses. The service must be explicitly disabled to prevent it from restarting. The <b>SERVICE_CONFIG_LAUNCH_PROTECTED</b> value can be used to launch the service as protected. In order to launch the service as protected, the service must be signed with a special certificate.</para>
		/// <para>SERVICE_CONFIG_LAUNCH_PROTECTED example:</para>
		/// <para></para>
		/// <para>This doc was truncated.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-changeserviceconfig2w#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ADVAPI32.dll", ExactSpelling = true, SetLastError = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        [SupportedOSPlatform("windows")]
        internal static extern unsafe winmdroot.Foundation.BOOL ChangeServiceConfig2W(winmdroot.System.Services.SC_HANDLE hService, winmdroot.System.Services.SERVICE_CONFIG dwInfoLevel, [Optional] void* lpInfo);

		/// <inheritdoc cref="ControlService(winmdroot.System.Services.SC_HANDLE, uint, winmdroot.System.Services.SERVICE_STATUS*)"/>
		[SupportedOSPlatform("windows")]
		internal static unsafe winmdroot.Foundation.BOOL ControlService(SafeHandle hService, uint dwControl, out winmdroot.System.Services.SERVICE_STATUS lpServiceStatus)
		{
			bool hServiceAddRef = false;
			try
			{
				fixed (winmdroot.System.Services.SERVICE_STATUS* lpServiceStatusLocal = &lpServiceStatus)
				{
					winmdroot.System.Services.SC_HANDLE hServiceLocal;
					if (hService is object)
					{
						hService.DangerousAddRef(ref hServiceAddRef);
						hServiceLocal = (winmdroot.System.Services.SC_HANDLE)hService.DangerousGetHandle();
					}
					else
						throw new ArgumentNullException(nameof(hService));
					winmdroot.Foundation.BOOL __result = PInvoke.ControlService(hServiceLocal, dwControl, lpServiceStatusLocal);
					return __result;
				}
			}
			finally
			{
				if (hServiceAddRef)
					hService.DangerousRelease();
			}
		}

		/// <summary>Sends a control code to a service. (ControlService)</summary>
		/// <param name="hService">
		/// <para>A handle to the service. This handle is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-openservicea">OpenService</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-createservicea">CreateService</a> function. The <a href="https://docs.microsoft.com/windows/desktop/Services/service-security-and-access-rights">access rights</a> required for this handle depend on the <i>dwControl</i> code requested.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-controlservice#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="dwControl">
		/// <para>This parameter can be one of the following control codes. </para>
		/// <para>This doc was truncated.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-controlservice#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <param name="lpServiceStatus">
		/// <para>A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/ns-winsvc-service_status">SERVICE_STATUS</a> structure that receives the latest service status information. The information returned reflects the most recent status that the service reported to the service control manager.</para>
		/// <para>The service control manager fills in the structure only when [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) returns one of the following error codes: <b>NO_ERROR</b>, <b>ERROR_INVALID_SERVICE_CONTROL</b>, <b>ERROR_SERVICE_CANNOT_ACCEPT_CTRL</b>, or <b>ERROR_SERVICE_NOT_ACTIVE</b>. Otherwise, the structure is not filled in.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-controlservice#parameters">Read more on docs.microsoft.com</see>.</para>
		/// </param>
		/// <returns>
		/// <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following error codes can be set by the service control manager. Other error codes can be set by the registry functions that are called by the service control manager. </para>
		/// <para>This doc was truncated.</para>
		/// </returns>
		/// <remarks>
		/// <para>The <b>ControlService</b> function asks the Service Control Manager (SCM) to send the requested control code to the service. The SCM sends the code  if the service has specified that it will accept the code, and is in a state in which a control code can be sent to it. The SCM processes service control notifications in a serial fashion—it will wait for one service to complete processing a service control notification before sending the next one. Because of this, a call to <b>ControlService</b> will block for 30 seconds if any service is busy handling a control code. If the busy service still has not returned from its handler function when the timeout expires, <b>ControlService</b> fails with <b>ERROR_SERVICE_REQUEST_TIMEOUT</b>. To stop and start a service requires a security descriptor that allows you to do so. The default security descriptor allows the <a href="https://docs.microsoft.com/windows/desktop/Services/localsystem-account">LocalSystem account</a>, and members of the Administrators and Power Users groups to stop and start services. To change the security descriptor of a service, see <a href="https://docs.microsoft.com/windows/desktop/Services/modifying-the-dacl-for-a-service">Modifying the DACL for a Service</a>. The <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-queryservicestatusex">QueryServiceStatusEx</a> function returns a <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/ns-winsvc-service_status_process">SERVICE_STATUS_PROCESS</a> structure whose <b>dwCurrentState</b> and <b>dwControlsAccepted</b> members indicate the current state and controls accepted by a running service. All running services accept the <b>SERVICE_CONTROL_INTERROGATE</b> control code by default. Drivers do not accept control codes other than <b>SERVICE_CONTROL_STOP</b> and <b>SERVICE_CONTROL_INTERROGATE</b>. Each service specifies the other control codes that it accepts when it calls the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-setservicestatus">SetServiceStatus</a> function to report its status. A service should always accept these codes when it is running, no matter what it is doing. The following table shows the action of the SCM  in each of the possible service states. </para>
		/// <para>This doc was truncated.</para>
		/// <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-controlservice#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[DllImport("ADVAPI32.dll", ExactSpelling = true, SetLastError = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[SupportedOSPlatform("windows")]
		internal static extern unsafe winmdroot.Foundation.BOOL ControlService(winmdroot.System.Services.SC_HANDLE hService, uint dwControl, winmdroot.System.Services.SERVICE_STATUS* lpServiceStatus);
	}
}
